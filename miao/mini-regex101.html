<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>正则</title>
  <style>
    b {
      /*变量声明*/
      [dataId="1"] {
        --group-color: #9fcba1;
      }
      [dataId="2"] {
        --group-color: #e0bf8b;
      }
      [dataId="3"] {
        --group-color: #acadfc;
      }
      [dataId="4"] {
        --group-color: #e1abf5;
      }
      [dataId="5"] {
        --group-color: #ef9b95;
      }
      font-weight: normal;
      color: black;
      position: relative;
      &:hover{
        box-shadow: 0 0 3px rgb(106, 99, 99),0 0 3px rgb(106, 99, 99);
      }
      &:hover::after {
        content: "match:"attr(data-index);
        position: absolute;
        bottom: 120%;
        left:0px;
        color:white ;
        background-color: black;
        padding:5px;
        border-radius: 5px;
      }
      &:nth-child(odd) {
        background-color: rgb(99, 177, 249);

        & i {
          background-color: color-mix(in srgb, var(--group-color) 60%, white);
        }
      }
      &:nth-child(even) {
        background-color: rgb(188, 219, 247);
        & i {
          background-color: var(--group-color);
        }
      }
    }

    em {
      outline: red 1px solid;
      position: relative;
    }

    i[dataId] {
      font-weight: normal;
      font-style: normal;
      position: relative;
      z-index: 1;
    }



    div {
      position: relative;
      display: flex;
      >* {
        border: 2px solid #9fcfff;
        padding: 0;
        margin: 0px;
        /* position: absolute; */
        width: 300px;
        height: 300px;
        background-color: transparent;
        font-size: large;
        text-wrap: wrap;
        overflow-wrap: break-word;
      }

      >pre {
        /* z-index: -1; */
      }
    }
  </style>
</head>

<body>
  正则: <br>
  <input type="text" id="regString" oninput="run()" value="ab(c)"> <button onclick="run()">run</button><br>
  <label>I <input type="checkbox" oninput="run()" id="checkI"></label>
  <label>S <input type="checkbox" oninput="run()" id="checkS"></label>
  <label>G <input type="checkbox" oninput="run()" checked id="checkG"></label>
  <label>M <input type="checkbox" oninput="run()" id="checkM"></label>
  <label>Y <input type="checkbox" oninput="run()" id="checkY"></label>
  <p><span>msg:</span><span id="msg"></span></p>
  <br>
  匹配字符串:
  <div>
    <textarea name="" id="inputString" cols="30" rows="10" oninput="run()">Tomsay:'abc'abc'asdasd.'asdas:'i'm strong.'Lucy:'can can  need?' Tom say:'How  are you?''
    </textarea>
    <pre id="pre"></pre>
  </div>
</body>
<script>
  run()
  function run() {
    var flag = ""
    if (checkI.checked) {
      flag += "i"
    }
    if (checkG.checked) {
      flag += "g"
    }
    if (checkM.checked) {
      flag += "m"
    }
    if (checkY.checked) {
      flag += "y"
    }
    if (checkS.checked) {
      flag += "s"
    }
    var string = inputString.value
    try {
      var re = new RegExp(regString.value, "d" + flag)
    } catch (error) {
      msg.innerHTML = error.name
      return
    }
    msg.innerHTML = ""
    var match
    var leftMap = {}
    var resultStr = ""
    var preIndex = 0
    var count = 0
    while (match = re.exec(string)) {
      resultStr += string.slice(preIndex, match.index)
      preIndex = re.lastIndex
      var indices = match.indices

      //****0宽断言****
      //匹配长度为0的时候,lastIndex是不变的,此时为0宽断言
      if (match[0] == '') {
        //在match.index前拼上em标签
        re.lastIndex++
        resultStr += "<em></em>"
      }

      //处理匹配到的字符串index - lastindex
      var matchStr = match[0]

      //****分组情况****
      //如果使用或可能会出现分组为undefind的情况 所以先过滤掉空白分组
      indices = indices.filter(e => e)
      //如果存在分组,取出匹配到的分组,映射储存的是相对下标有几个tag
      if (indices.length > 1) {
        resultStr += `<b data-index =${count} >`
        count++
        indices = indices.slice(1)

        var leftTagsMap = indices.reduce((map, e, i) => {
          if (!e) {
            return map
          }
          var position = e[0] - match.index
          if (map[position]) {
            map[position]++
          } else {
            map[position] = 1
          }
          return map
        }, {})
        var rightTagsMap = indices.reduce((map, e, i) => {
          var position = e[1] - match.index
          if (map[position]) {
            map[position]++
          } else {
            map[position] = 1
          }
          return map
        }, {})
        //拼接匹配的字符串
        var i = 1 //i作为组号
        for (var index = 0; index < matchStr.length; index++) {
          var leftTag = ""
          var rightTag = ""
          while (leftTagsMap[index]) {
            leftTag += `<i dataId =${i} >`
            i++
            leftTagsMap[index]--
          }
          while (rightTagsMap[index]) {
            rightTag += `</i>`
            rightTagsMap[index]--
          }
          if (leftTag && rightTag) {
            //如果左右标签同时存在一个下标上
            //左+右+当前下标
            resultStr += rightTag + leftTag + matchStr[index]
          } else {
            resultStr += leftTag + rightTag + matchStr[index]
          }
        }
        rightTag = ""
        while (rightTagsMap[index]) {
          rightTag += `</i>`
          rightTagsMap[index]--
        }
        resultStr += rightTag
        resultStr += "</b>"
      } else if (indices.length == 1 && match[0] !== '') {
        //没有分组
        //两边加上<b>
        resultStr += `<b data-index =${count} >${matchStr}</b>`
        count++
      }


      //****非全局情况****
      if (!re.global) {
        //如果g没有设定则 lastindex 为0
        preIndex = match.indices[0][1]
        break
      }
    }

    //循环结束后将剩余部分拼接
    resultStr += string.slice(preIndex)
    // var resultStr=getStr(left,right,string)
    pre.innerHTML = resultStr
  }

</script>

</html>
